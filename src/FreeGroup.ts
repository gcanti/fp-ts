/**
 * @file The free group generated by elements of `A`, up to equality. Note that the `Setoid` and `Monoid` instances differ
 * from the standard such instances for `Array<Either<A, A>>`; two elements of the free group are equal iff they are equal
 * after being reduced to "canonical form", i.e., cancelling adjacent inverses.
 *
 * Adapted from https://hackage.haskell.org/package/free-algebras-0.0.7.0/docs/Data-Group-Free.html
 */
import { empty as emptyArray, getMonoid as getArrayMonoid, getSetoid as getArraySetoid, array } from './Array'
import { Either, getSetoid as getEitherSetoid, left, right, either, isLeft } from './Either'
import { Group } from './Group'
import { Setoid, fromEquals } from './Setoid'
import { Monad1 } from './Monad'

declare module './HKT' {
  interface URI2HKT<A> {
    FreeGroup: FreeGroup<A>
  }
}

export const URI = 'FreeGroup'

export type URI = typeof URI

/**
 * @since 1.13.0
 */
export interface FreeGroup<A> extends Array<Either<A, A>> {}

const of = <A>(a: A): FreeGroup<A> => {
  return [right(a)]
}

const map = <A, B>(fa: FreeGroup<A>, f: (a: A) => B): FreeGroup<B> => {
  return fa.map(e => either.bimap(e, f, f))
}

const ap = <A, B>(fab: FreeGroup<(a: A) => B>, fa: FreeGroup<A>): FreeGroup<B> => {
  return chain(fab, f => map(fa, f)) // <- derived
}

const get = <A>(e: Either<A, A>): A => (e._tag === 'Left' ? e.left : e.right)

const chain = <A, B>(fa: FreeGroup<A>, f: (a: A) => FreeGroup<B>): FreeGroup<B> => {
  return array.chain(fa, e => f(get(e)))
}

/**
 * Reduce a term of a free group to canonical form, i.e. cancelling adjacent inverses.
 *
 * @since 1.13.0
 */
export const normalize = <A>(S: Setoid<A>) => (g: Array<Either<A, A>>): FreeGroup<A> => {
  return g.reduceRight((acc: FreeGroup<A>, s) => {
    if (acc.length > 0) {
      const head = acc[0]
      if (head._tag !== s._tag && S.equals(get(head), get(s))) {
        return acc.slice(1)
      }
    }
    acc.unshift(s)
    return acc
  }, [])
}

/**
 * @since 1.13.0
 */
export const getSetoid = <A>(S: Setoid<A>): Setoid<FreeGroup<A>> => {
  const AS = getArraySetoid(getEitherSetoid(S, S))
  const normalizeS = normalize(S)
  return fromEquals((x, y) => AS.equals(normalizeS(x), normalizeS(y)))
}

/**
 * @since 1.13.0
 */
export const empty: FreeGroup<never> = emptyArray

/**
 * @since 1.13.0
 */
export const getGroup = <A>(S: Setoid<A>): Group<FreeGroup<A>> => {
  const M = getArrayMonoid<Either<A, A>>()
  const normalizeS = normalize(S)
  return {
    concat: (x, y) => normalizeS(M.concat(x, y)),
    empty,
    inverse: x =>
      x
        .slice()
        .reverse()
        .map(s => (isLeft(s) ? right(s.left) : left(s.right)))
  }
}

/**
 * @since 1.13.0
 */
export const freeGroup: Monad1<URI> = {
  URI,
  of,
  map,
  ap,
  chain
}
